{"version":3,"sources":["../../../../../src/api/agent/service/agent/agent.service.ts"],"sourcesContent":["import { BadRequestException, Injectable, Logger } from '@nestjs/common';\r\nimport { BaseMessage, HumanMessage } from '@langchain/core/messages';\r\nimport { Observable } from 'rxjs';\r\nimport { map } from 'rxjs/operators';\r\nimport { SseMessage } from '../../dto/sse.dto';\r\nimport { MessageDto, SseMessageDto } from '../../dto/message.dto';\r\nimport { MessageUtil } from '../../utils/message.util';\r\nimport { IAgentService } from '../iagent.service';\r\nimport { ReactAgent } from 'src/agent/implementations/react.agent';\r\nimport { MessageResponseDto } from '../../dto/message.response.dto';\r\nimport { RedisService } from 'src/messaging/redis/redis.service';\r\nimport { TicketDto } from '../../dto/ticket.dto';\r\nimport { TicketAnalysisResponseDto } from '../../dto/ticket-response.dto';\r\n\r\n@Injectable()\r\nexport class AgentService implements IAgentService {\r\n  private readonly logger = new Logger(AgentService.name);\r\n\r\n  constructor(\r\n    private agent: ReactAgent,\r\n    private redisService: RedisService,\r\n  ) {}\r\n\r\n  async analyzeTicket(ticketDto: TicketDto): Promise<TicketAnalysisResponseDto> {\r\n    const startTime = Date.now();\r\n    const config = {\r\n      configurable: { thread_id: ticketDto.threadId },\r\n    };\r\n\r\n    try {\r\n      const message = await this.agent.chat(\r\n        {\r\n          messages: [\r\n            new HumanMessage(\r\n              `Analyze this support ticket and provide recommendations: ${ticketDto.ticketText}`,\r\n            ),\r\n          ],\r\n        },\r\n        config,\r\n      );\r\n\r\n      const rawContent =\r\n        typeof message.content === 'string'\r\n          ? message.content\r\n          : JSON.stringify(message.content);\r\n\r\n      const parsed = this.parseAgentResponse(rawContent);\r\n      const processingTime = Date.now() - startTime;\r\n\r\n      return {\r\n        threadId: ticketDto.threadId,\r\n        classification: parsed.classification,\r\n        metadata: parsed.metadata,\r\n        knowledge_articles: parsed.knowledge_articles,\r\n        historical_tickets: parsed.historical_tickets,\r\n        recommendations: parsed.recommendations,\r\n        tools_used: parsed.tools_used || [],\r\n        complexity_assessment: parsed.complexity_assessment || 'unknown',\r\n        raw_response: rawContent,\r\n        processing_time_ms: processingTime,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Error analyzing ticket', error);\r\n      throw new BadRequestException(\r\n        error.message || 'An error occurred while analyzing the ticket.',\r\n      );\r\n    }\r\n  }\r\n\r\n  async chat(messageDto: MessageDto): Promise<MessageResponseDto> {\r\n    const messages = MessageUtil.toHumanMessages(messageDto);\r\n    const config = {\r\n      configurable: { thread_id: messageDto.threadId },\r\n    };\r\n    try {\r\n      const message = await this.agent.chat(\r\n        {\r\n          messages,\r\n        },\r\n        config,\r\n      );\r\n      return {\r\n        id: message.id || 'unknown',\r\n        type: message.getType() as 'human' | 'ai' | 'tool',\r\n        content: message.content,\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Error in chat:', error);\r\n      throw new BadRequestException(\r\n        error.message || 'An error occurred while processing your request.',\r\n      );\r\n    }\r\n  }\r\n\r\n  async stream(message: SseMessageDto): Promise<Observable<SseMessage>> {\r\n    const channel = `agent-stream:${message.threadId}`;\r\n    this.logger.log(`Streaming messages to channel: ${channel}`);\r\n\r\n    this.streamMessagesToRedis(\r\n      [new HumanMessage(message.content)],\r\n      { configurable: { thread_id: message.threadId } },\r\n      channel,\r\n    );\r\n\r\n    return this.redisService\r\n      .subscribe(channel)\r\n      .pipe(map((msg) => JSON.parse(msg) as SseMessage));\r\n  }\r\n\r\n  private async streamMessagesToRedis(\r\n    messages: BaseMessage[],\r\n    configurable: Record<string, any>,\r\n    channel: string,\r\n  ) {\r\n    try {\r\n      const streams = await this.agent.stream(\r\n        { messages },\r\n        {\r\n          streamMode: 'messages',\r\n          ...configurable,\r\n        },\r\n      );\r\n\r\n      for await (const chunk of streams) {\r\n        if (!chunk) continue;\r\n\r\n        const messageChunks = Array.isArray(chunk)\r\n          ? chunk.filter((item) => item?.constructor?.name === 'AIMessageChunk')\r\n          : [];\r\n\r\n        for (const messageChunk of messageChunks) {\r\n          await this.redisService.publish(\r\n            channel,\r\n            JSON.stringify({\r\n              data: {\r\n                id: messageChunk.id,\r\n                type: messageChunk.getType() as 'human' | 'ai' | 'tool',\r\n                content: messageChunk.content,\r\n              },\r\n              type: 'message',\r\n            }),\r\n          );\r\n        }\r\n      }\r\n\r\n      await this.redisService.publish(\r\n        channel,\r\n        JSON.stringify({ data: { id: 'done', content: '' }, type: 'done' }),\r\n      );\r\n    } catch (error) {\r\n      this.logger.error('Error in streamMessagesToRedis:', error);\r\n      await this.redisService.publish(\r\n        channel,\r\n        JSON.stringify({ type: 'error', data: { message: error.message } }),\r\n      );\r\n    }\r\n  }\r\n\r\n  async getHistory(threadId: string): Promise<MessageResponseDto[]> {\r\n    try {\r\n      const history = await this.agent.getHistory(threadId);\r\n      return history\r\n        .map((msg: BaseMessage) => ({\r\n          id: msg.id || 'unknown',\r\n          type: msg.getType() as 'human' | 'ai' | 'tool',\r\n          content: msg.content,\r\n        }))\r\n        .filter((msg) => msg.content);\r\n    } catch (error) {\r\n      this.logger.error('Error fetching history:', error);\r\n      throw new BadRequestException(\r\n        error.message || 'An error occurred while fetching history.',\r\n      );\r\n    }\r\n  }\r\n\r\n  private parseAgentResponse(rawContent: string): any {\r\n    try {\r\n      const jsonMatch = rawContent.match(/\\{[\\s\\S]*\\}/);\r\n      if (jsonMatch) {\r\n        return JSON.parse(jsonMatch[0]);\r\n      }\r\n    } catch {\r\n      this.logger.warn('Could not parse structured JSON from agent response');\r\n    }\r\n\r\n    return {\r\n      classification: null,\r\n      metadata: null,\r\n      knowledge_articles: [],\r\n      historical_tickets: [],\r\n      recommendations: {\r\n        summary: rawContent,\r\n        immediate_actions: [],\r\n        resolution_steps: [],\r\n        estimated_resolution_time: 'unknown',\r\n        escalation_needed: false,\r\n      },\r\n      tools_used: [],\r\n      complexity_assessment: 'unknown',\r\n    };\r\n  }\r\n}\r\n"],"names":["AgentService","analyzeTicket","ticketDto","startTime","Date","now","config","configurable","thread_id","threadId","message","agent","chat","messages","HumanMessage","ticketText","rawContent","content","JSON","stringify","parsed","parseAgentResponse","processingTime","classification","metadata","knowledge_articles","historical_tickets","recommendations","tools_used","complexity_assessment","raw_response","processing_time_ms","error","logger","BadRequestException","messageDto","MessageUtil","toHumanMessages","id","type","getType","stream","channel","log","streamMessagesToRedis","redisService","subscribe","pipe","map","msg","parse","streams","streamMode","chunk","messageChunks","Array","isArray","filter","item","name","messageChunk","publish","data","getHistory","history","jsonMatch","match","warn","summary","immediate_actions","resolution_steps","estimated_resolution_time","escalation_needed","Logger"],"mappings":"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"}